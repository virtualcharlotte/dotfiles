#!/usr/bin/env node
// Generated by CoffeeScript 1.9.3
var HOME, VERSION, _, config, configPath, exitWithError, fileExists, fs, i3Path, mkConfig, mkTheme, outputPath, pathUtil, program, ref, ref1, sh, theme, themesAvailable, themesDir, themesList, tmpConfigPath, tmpPath, tmpdir, validation, yaml, yamlTheme,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('underscore');

fs = require('fs');

sh = require('shelljs');

program = require('commander');

yaml = require('js-yaml');

pathUtil = require('path');

ref = require('./index'), mkConfig = ref.mkConfig, mkTheme = ref.mkTheme;

VERSION = require('../package.json').version;

sh.config.silent = true;

fileExists = function(path) {
  return (path != null) && sh.test('-f', path);
};

exitWithError = function(msg) {
  program.outputHelp();
  process.stderr.write("Error: " + msg + "\n");
  return process.exit(1);
};

program.version(VERSION).usage('<theme> [options]').option('-c, --config <file>', 'The config file the theme should be applied to. Defaults to the default i3 location.').option('-o, --output <file>', 'Apply the theme, attempt to validate the result, and write it to <file>. Print to STDOUT if no output file is given.').option('-s, --save', 'Set the output file to the path of the input file.').option('-r, --reload', 'Apply the theme by reloading the config.').option('-l, --list-all', 'Print a list of all available themes.').option('-t, --to-theme [file]', 'Prints an i3-style theme based on the given config suitable for sharing with others.').parse(process.argv);

themesDir = pathUtil.resolve(__dirname, '../themes');

themesAvailable = sh.ls(themesDir);

if (program.listAll) {
  sh.echo('\n  Available themes:\n');
  themesList = [];
  themesAvailable.forEach(function(themePath) {
    var i, paddedName, ref1, theme;
    theme = yaml.safeLoad(sh.cat(pathUtil.join(themesDir, themePath)));
    paddedName = ((function() {
      var j, results;
      results = [];
      for (i = j = 0; j <= 17; i = ++j) {
        results.push(themePath[i] || ' ');
      }
      return results;
    })()).join('');
    return themesList.push("    " + paddedName + " - " + (((ref1 = theme.meta) != null ? ref1.description : void 0) || ''));
  });
  sh.echo(themesList.join('\n') + '\n');
  process.exit(0);
}

HOME = process.env.HOME;

configPath = (function() {
  switch (false) {
    case !program.config:
      return program.config;
    case !_.isString(program.toTheme):
      return program.toTheme;
    case !(HOME && fileExists(HOME + "/.i3/config")):
      return HOME + "/.i3/config";
    case !(HOME && fileExists(HOME + "/.config/i3/config")):
      return HOME + "/.config/i3/config";
    default:
      return exitWithError("Could not find a valid i3 config file");
  }
})();

if (!fileExists(configPath)) {
  exitWithError("Config file not found: " + configPath);
}

if (program.toTheme) {
  theme = mkTheme(sh.cat(configPath));
  yamlTheme = "# vim: filetype=yaml\n---\n" + (yaml.safeDump(theme));
  if (program.output) {
    fs.writeFileSync(program.output, yamlTheme);
  } else {
    sh.echo(yamlTheme);
  }
  process.exit(0);
}

if (!program.args.length) {
  program.outputHelp();
  process.exit(0);
}

if (!(fileExists(program.args[0]) || (ref1 = program.args[0], indexOf.call(themesAvailable, ref1) >= 0))) {
  exitWithError("Theme or file not found: " + program.args[0]);
}

theme = (function() {
  var ref2;
  switch (false) {
    case !program.args[0].match(/\.json$/):
      return JSON.parse(sh.cat(program.args[0]));
    case !(program.args[0].match(/\.yaml$/) || program.args[0].match(/\.yml$/)):
      return yaml.safeLoad(sh.cat(program.args[0]));
    case ref2 = program.args[0], indexOf.call(themesAvailable, ref2) < 0:
      return yaml.safeLoad(sh.cat(pathUtil.join(themesDir, program.args[0])));
    default:
      return yaml.safeLoad(sh.cat(program.args[0]));
  }
})();

config = mkConfig(theme, sh.cat(configPath));

outputPath = (function() {
  switch (false) {
    case !program.output:
      return program.output;
    case !program.save:
      return configPath;
    default:
      return null;
  }
})();

if (!outputPath) {
  sh.echo(config);
  if (program.reload) {
    sh.exec('i3-msg reload');
  }
  process.exit(0);
}

i3Path = sh.which('i3');

tmpdir = sh.tempdir();

if (i3Path && tmpdir) {
  tmpConfigPath = pathUtil.join(tmpdir, 'i3-style-config');
  fs.writeFileSync(tmpConfigPath, config);
  if (fileExists(tmpConfigPath)) {
    validation = sh.exec(i3Path + " -c " + tmpConfigPath + " -C");
    sh.rm(tmpConfigPath);
    if (validation.output.indexOf('ERROR:') > 0 || validation.code > 0) {
      exitWithError("Could not validate output configuration.\n\n" + validation.output);
    }
  }
}

if (tmpdir && !process.env.I3STYLETEST) {
  sh.mkdir(pathUtil.join(tmpdir, 'i3-style'));
  tmpPath = pathUtil.join(tmpdir, 'i3-style', "config.bak." + (Date.now()));
  sh.echo(configPath + " -> " + tmpPath);
  sh.cp(configPath, tmpPath);
}

fs.writeFile(outputPath, config, function(err) {
  if (err) {
    exitWithError("Could not write to file: " + program.output + "\n\n" + err);
  }
  sh.echo("Applied " + program.args[0] + " theme to " + outputPath);
  if (program.reload) {
    return sh.exec('i3-msg reload');
  }
});
